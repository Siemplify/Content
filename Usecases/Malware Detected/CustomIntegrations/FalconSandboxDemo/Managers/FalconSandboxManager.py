# ============================================================================#
# title           :FalconSandboxManager.py
# description     :This Module contain all Falcon Sandbox operations functionality
# author          :avital@siemplify.co
# date            :28-03-2018
# python_version  :2.7
# libreries       :requests
# requirments     :
# product_version :1.0
# ============================================================================#

# ============================= IMPORTS ===================================== #
import requests

requests.packages.urllib3.disable_warnings()

# ============================== CONSTS ===================================== #
FALCON_API_ROOT_V2 = "https://www.hybrid-analysis.com/api/v2"

HEADERS = {
    'User-Agent': 'FalconFalcon Sandbox',
    'api-key': None
}
COMPLETED_STATUS = "SUCCESS"
ERROR_STATUS = "ERROR"
ENVIRONMENTS = {
    '100': 'Windows 7 32 bit',
    '110': 'Windows 7 32 bit (HWP Support)',
    '120': 'Windows 7 64 bit',
    '200': 'Android Static Analysis',
    '300': 'Linux (Ubuntu 16.04, 64 bit)'
}


# ============================= CLASSES ===================================== #
class FalconSandboxManagerError(Exception):
    """
    General Exception for Falcon Sandbox manager
    """
    pass


class FalconSandboxManager(object):

    def __init__(self, server_address, api_key):
        self.server_address = server_address
        self.api_key = api_key
        self.headers = HEADERS
        self.headers['api-key'] = api_key

    def test_connectivity(self):
        """
        Test connectivity to Falcon Sandbox
        :return: {bool} True if connection successful, False otherwise.
        """
        url = "{}/system/heartbeat".format(self.server_address)
        response = requests.get(url, headers=self.headers)
        self.validate_response(response)
        return True

    def submit_file(self, file_path, environment_id):
        """
        Submit a file for analysis
        :param file_path: {str} The path of the file to analyze
        :param environment_id:Environment ID. Available environments ID:
            300: 'Linux (Ubuntu 16.04, 64 bit)',
            200: 'Android Static Analysis',
            120: 'Windows 7 64 bit',
            110: 'Windows 7 32 bit (HWP Support)',
            100: 'Windows 7 32 bit'
        :return: {tuple} The new job's id, The hash of the uploaded file
        """
        files = {'file': open(file_path, 'rb')}
        url = "{}/submit/file".format(self.server_address)
        response = requests.post(url,
                                 data={"environment_id": environment_id},
                                 files=files,
                                 headers=self.headers)

        self.validate_response(response)
        return response.json()['job_id'], response.json()['sha256']

    def submit_file_by_url(self, url_to_analyze, environment_id):
        """
        Submit a file by url for analysis
        :param url_to_analyze: {str} The url to the file to analyze
        :param environment_id:Environment ID. Available environments ID:
            300: 'Linux (Ubuntu 16.04, 64 bit)',
            200: 'Android Static Analysis',
            120: 'Windows 7 64 bit',
            110: 'Windows 7 32 bit (HWP Support)',
            100: 'Windows 7 32 bit'
        :return: {str} The new job's id
        """
        url = "{}/submit/url-to-file".format(self.server_address)
        response = requests.post(url,
                                 data={"environment_id": environment_id,
                                       "url": url_to_analyze},
                                 headers=self.headers)
        self.validate_response(response)
        return response.json()['job_id'], response.json()['sha256']

    def is_job_completed(self, job_id):
        """
        Check if a given job has completed.
        :param job_id: {str} The job's id
        :return: {bool} True if completed or error, False otherwise.
        """
        url = "{}/report/{}/state".format(self.server_address, job_id)
        response = requests.get(url, headers=self.headers)
        self.validate_response(response)
        return response.json()['state'] == COMPLETED_STATUS or response.json()['state'] == ERROR_STATUS

    def get_report(self, job_id, type='misp'):
        """
        Download a report for a given job
        :param job_id: {str} The job's id
        :param type: {str} The report file type. Available types:
            xml, json, pdf, html, pcap, maec, stix, misp, misp-json, openioc,
            bin, crt, memory.
            For details visit:
                https://www.hybrid-analysis.com/docs/api/v2#/Report/get_report__id__file__type_
        :return: {tuple} The file name of the report, the report content
        """
        url = "{}/report/{}/file/{}".format(self.server_address, job_id, type)
        response = requests.get(url, headers=self.headers)
        self.validate_response(response)
        return response.headers['Vx-Filename'], response.content

    def get_report_by_hash(self, hash, env_id, type='misp'):
        """
        Download a report for a given hash and environment id
        :param hash: {str} The hash
        :param env_id: {str} The env id
        :param type: {str} The report file type. Available types:
            xml, json, pdf, html, pcap, maec, stix, misp, misp-json, openioc,
            bin, crt, memory.
            For details visit:
                https://www.hybrid-analysis.com/docs/api/v2#/Report/get_report__id__file__type_
        :return:{tuple} The file name of the report, the report content
        """
        url = "{}/report/{}:{}/file/{}".format(self.server_address, hash, env_id, type)
        response = requests.get(url, headers=self.headers)
        self.validate_response(response)
        return response.headers['Vx-Filename'], response.content

    def get_scan_info(self, filehash, environment_id):
        """
        Get the scan info of a given hash
        :param filehash: {str} hash
        :param environment_id:Environment ID. Available environments ID:
            300: 'Linux (Ubuntu 16.04, 64 bit)',
            200: 'Android Static Analysis',
            120: 'Windows 7 64 bit',
            110: 'Windows 7 32 bit (HWP Support)',
            100: 'Windows 7 32 bit'
        :return:{json} The scan info
        """
        url = "{}/report/summary".format(self.server_address)
        response = requests.post(url,
                                data={
                                    'hashes[]': ["{}:{}".format(filehash, environment_id)]
                                },
                                headers=self.headers)
        self.validate_response(response)
        return response.json()

    def search(self, filename=None, filetype=None, filetype_desc=None,
               verdict=None,
               av_detect=None, vx_family=None, tag=None, port=None, host=None,
               domain=None,
               url=None, similar_to=None, context=None):
        """
        Search for an existing analysis
        :param filename: {str} Filename e.g. invoice.exe
        :param filetype: {str} Filetype e.g. docx
        :param filetype_desc: {str} Filetype description e.g. PE32 executable
        :param verdict: {int} Verdict e.g. 1 (available: 1 'whitelisted', 2 'no verdict', 3 'no specific threat', 4 'suspicious', 5 'malicious')
        :param av_detect: {str} AV Multiscan range e.g. 50-70 (min 0, max 100)
        :param vx_family: {str} AV Family Substring e.g. nemucod
        :param tag: {str} Hashtag e.g. ransomware
        :param port: {int} Port e.g. 8080
        :param host: {str} Host e.g. 192.168.0.1
        :param domain: {str} Domain e.g. checkip.dyndns.org
        :param url: {str} HTTP Request Substring e.g. google
        :param similar_to: {str} Similar Samples e.g. <sha256>
        :param context: {str} Sample Context e.g. <sha256>
        :return: {list} List of found results, in the following format:
            {
              "verdict": "string",
              "av_detect": "string",
              "threat_score": 0,
              "vx_family": "string",
              "job_id": "string",
              "sha256": "string",
              "environment_id": "string",
              "analysis_start_time": "2018-03-28T14:10:20.608Z",
              "submit_name": "string",
              "environment_description": "string",
              "size": 0,
              "type": "string",
              "type_short": "string"
            }
        """
        search_terms = {
            "filename": filename,
            "filetype": filetype,
            "filetype_desc": filetype_desc,
            "verdict": verdict,
            "av_detect": av_detect,
            "vx_family": vx_family,
            "tag": tag,
            "port": port,
            "host": host,
            "domain": domain,
            "url": url,
            "similar_to": similar_to,
            "context": context
        }

        # Remove None values (since / to) to prevent exception from the server
        search_terms = {key: value for key, value in search_terms.items() if
                        value}

        request_url = "{}/search/terms".format(self.server_address)
        response = requests.post(request_url, data=search_terms,
                                 headers=self.headers)
        self.validate_response(response)
        return response.json()['result']

    @staticmethod
    def validate_response(response):
        try:
            response.raise_for_status()

        except Exception as e:
            try:
                response.json()
            except:
                raise FalconSandboxManagerError(
                    "{}\n{}".format(e.message, response.content))

            raise FalconSandboxManagerError(
                "{}\n{}".format(e.message, response.json()['message']))

    @staticmethod
    def construct_csv(results):
        """
        Construct csv output from results
        :param results: {list} The results to format (list of lfat dicts)
        :return: {list} csv formatted list
        """
        csv_output = []
        headers = reduce(set.union, map(set, map(dict.keys, results)))

        csv_output.append(",".join(map(str, headers)))

        for result in results:
            csv_output.append(
                ",".join([s.replace(',', ' ') for s in
                          map(str,
                              [unicode(result.get(h, None)).encode('utf-8') for
                               h in headers])]))
        return csv_output


